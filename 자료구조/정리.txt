0 - 1.
*
int* ptr; 포인터 변수
cout << *ptr; ptr이 가리키는 주소 내부의 값

&
Temp(int& temp); 참조 변수
cout << &temp; temp의 주소값

지역 변수에 포인터를 반환하면 지역 변수가 소멸되면 메모리 누수가 일어남

table[0] == *(table)
table[0][0] == *(*(table))
table[i][j] == *(*(table + i) + j)

int (*p)[10]; 배열 포인터
int* p[10]; 포인터 배열

Global 전역 변수 저장, 프로그램 종료 시 할당 해제
Heap 동적 메모리 할당, 할당 해제 입력 시 할당 해
Stack 지역 변수 저장, 함수 종료 시 할당 해제

동적 메모리 할당 VS 정적 메모리 할당
정적 메모리 할당 - 메모리 할당 필요 X, 메모리 할당 해제 불가능, 메모리 사이즈 키우기 불가능, 메모리 사이즈 줄이기 불가능
장점 - 쉬움, 인덱스만 쓰면 OK
단점 - 고정된 메모리 공간, 예기치 않은 메모리 접근에 취약

동적 메모리 할당 - New로 메모리 할당, Delete로 메모리 할당 해제, 메모리 사이즈 키우기 쉬움, 메모리 사이즈 줄이기 쉬움
장점 - 메모리 사용에 최적화됨
단점 - 포인터 관리가 복잡함

0 - 2.
점점 프로그래머의 몸값이 컴퓨터보다 비싸지고 있음

인터페이스는 다른 클래스에서 사용될 메소드와 변수를 미리 정의해 놓음으로써, 코드의 재사용성과 유지보수성을 높일 수 있다

캡슐화 - 클래스 외부에서 직접적으로 접근이 불가능하도록 만듦
상속성 - 한 클래스가 다른 클래스의 특성을 물려받는 것
다형성 - 함수 오버로딩, 연산자 오버로딩, 가상 함수, 템플릿
추상화 - 객체의 공통적인 특징을 추출하여 이를 클래스로 정의하는 것

상속의 장점 - 재사용성

Public, Protected, Private - 캡슐화

Public에 멤버 함수, Private에 멤버 변수가 보통 들어가지만 그러지 않아도 된다

This Pointer - 객체들의 멤버 변수들과 멤버 함수들은 각 객체의 메모리에 저장되어 있다. This Pointer를 통해 접근한다.

생성자를 만들었다면 기본 생성자는 생성되지 않는다

함수 선언 시 기본 값은 변수에 대해 전부 선언해주거나 전부 선언해주지 않아야 한다. 몇몇 변수들만 선언하고 나머지는 하지 않으면 안된다

얕은 복사는 데이터 변경 영향 O, 깊은 복사는 데이터 변경 영향 X

부모 클래스의 소멸자에 Virtual을 달아줘야 함. 메모리 누수 발생 가능

1.

절차지향적 VS 객체지향적
객체지향적 - 가독성, 재사용성, 확장성이 좋음

2.
Precondition - 실행 전 참
Postcondition - 실행 후 참
Caller - Pre 보장, 함수 코드는 Post 보장

구현 레벨 .cpp
자료를 저장하기 위한 구조의 표현 명세 및 연산을 위한 코딩

논리 레벨 .h
자료의 범위와 연산의 추상적인 관점

응용 레벨 main.cpp
실세계에서 사용되는 자료 레벨

Unstructured vs Structured
Unstructured - 구성 요소는 서로 연관되지 않음. 클래스, '구조체'
Structured - 개별 데이터 구성 요소에 접근하는데 사용되는 방법이 정의되어 있음. 배열

List vs Array
Array는 Random Access가 가능하다
배열은 할당될 수 없다

정보 은닉 - 클래스 구현의 상세 내역이 감춰지는 것

3.
SortedList의 Key는 비교가 가능해야 한다

이진 탐색 추적 코드 빈칸 채우기

4.
Stack - LIFO, Push, Pop

Static Stack VS Dynamic Stack VS Linked Structure Stack
Static Stack
장점 - 구현이 쉽고 빠르다
단점 - 스택의 크기가 고정되어 있고 최대 크기를 넘어가면 오류가 발생한다

Dynamic Stack
장점 - 필요한 크기만큼 할당할 수 있다
단점 - 구현이 복잡하고, 메모리 관리에 주의해야 한다

Linked Stack
장점 - 크기에 제한이 없다
단점 - 메모리 사용량이 크다

Dangling Pointer - 할당 해제된 메모리를 가리키는 포인터

Queue - FIFO, Enqueue, Dequeue

Reserved가 있는 이유 - 기본적인 구조의 Queue에서는 첫 번째 요소가 빠지면 요소 전체를 앞으로 한 칸씩 밀어야 한다 = 연산

6.
Singular VS Doubly
장점 - 데이터 접근이 유연해짐, 역방향으로 이동 가능
단점 - 복잡해짐, 데이터 공간 소모 증가

Header, Trailer
Header는 맨 앞, Trailer는 맨 뒤 - 처음 마지막 노드는 삭제될 일이 없어서 조건문이 간단해짐 - List 처리 단순화

복사 생성자 VS 대입 연산자
이미 데이터가 들어가 있는 상태에서 사용되면 Dangling Pointer 발생 가능 = 메모리 누수 발생 가능 - 할당 해제 후 대입

Iterator Class
요소 순회 객체 - 안정성, 효율성